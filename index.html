<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Auto Runner Robot</title>
<style>
  body { margin: 0; background: #111; color: #fff; font-family: Arial, sans-serif; overflow: hidden; }
  canvas {
    background: #222 url('fond.png') no-repeat center center;
    background-size: cover;
    display: block;
    width: 100vw;
    height: 100vh;
  }
  #ui {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    font-size: 48px;
    text-align: center;
  }
</style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui"></div>
  <audio id="bgmusic" src="music.mp3" loop style="display:none"></audio>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui');
const music = document.getElementById('bgmusic');
const robotImg = new Image();
robotImg.src = 'robot.png';

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const GRAVITY = 0.6;
let speed = 4; // base speed, increases with level
const JUMP_VELOCITY = -24; // starting jump velocity
// Adjust hitboxes and obstacle size so jumps are survivable
const PLAYER_HITBOX_X = 30;
const PLAYER_HITBOX_Y = 20;
const OBSTACLE_WIDTH = 100;
const OBSTACLE_HEIGHT = 140;
const OBSTACLE_HITBOX = 10;

const player = {
  x: 80,
  y: 0,
  width: 160,
  height: 200,
  vy: 0,
  grounded: false
};

let obstacles = [];
let lives = 5;
let level = 1;
const maxLevel = 10;
let timeRemaining = 60;
let spawnTimer = 0;
let gameState = 'playing'; // playing, gameover, victory
let cameraX = 0;

function resetPlayer() {
  player.y = canvas.height - player.height;
  player.vy = 0;
  player.grounded = true;
}

function resetLevel(resetLives) {
  if (resetLives) lives = 5;
  timeRemaining = 60;
  spawnTimer = 0;
  cameraX = 0;
  obstacles = [];
  resetPlayer();
  music.play().catch(() => {});
}

function nextLevel() {
  if (level < maxLevel) {
    level++;
    speed += 0.5; // Increase speed each level
    resetLevel(false);
  } else {
    gameState = 'victory';
    music.pause();
  }
}

function gameOver() {
  gameState = 'gameover';
  music.pause();
}

const METER = 100; // basic unit for obstacle spacing

function spawnObstacle() {
  // distance the player covers during one full jump
  const jumpDist = Math.abs(JUMP_VELOCITY) / GRAVITY * 2 * speed;
  // obstacles appear with at least one jump length between them
  const gap = (1 + Math.random()) * jumpDist;
  // convert distance to time based on speed (px/frame) and 60 FPS
  spawnTimer = (gap / speed) * (1000 / 60);
  const obstacleWidth = OBSTACLE_WIDTH;
  const obstacleHeight = OBSTACLE_HEIGHT;
  const colors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71', '#9b59b6'];
  const color = colors[Math.floor(Math.random() * colors.length)];
  obstacles.push({
    x: cameraX + canvas.width,
    y: canvas.height - obstacleHeight,
    width: obstacleWidth,
    height: obstacleHeight,
    color
  });
}

function update(delta) {
  if (gameState !== 'playing') return;

  timeRemaining -= delta;
  if (timeRemaining <= 0) {
    nextLevel();
    return;
  }

  spawnTimer -= delta * 1000;
  if (spawnTimer <= 0) {
    spawnObstacle();
  }

  player.vy += GRAVITY;
  player.y += player.vy;

  if (player.y >= canvas.height - player.height) {
    player.y = canvas.height - player.height;
    player.vy = 0;
    player.grounded = true;
  }

  cameraX += speed;

  obstacles = obstacles.filter(ob => ob.x - cameraX + ob.width > 0);

  // collision
  obstacles.forEach(ob => {
    const px = player.x + PLAYER_HITBOX_X;
    const py = player.y + PLAYER_HITBOX_Y;
    const pw = player.width - PLAYER_HITBOX_X * 2;
    const ph = player.height - PLAYER_HITBOX_Y * 2;
    const ox = ob.x - cameraX + OBSTACLE_HITBOX;
    const oy = ob.y + OBSTACLE_HITBOX;
    const ow = ob.width - OBSTACLE_HITBOX * 2;
    const oh = ob.height - OBSTACLE_HITBOX * 2;
    if (px < ox + ow &&
        px + pw > ox &&
        py < oy + oh &&
        py + ph > oy) {
      lives--;
      if (lives <= 0) {
        gameOver();
      } else {
        resetLevel(false);
      }
    }
  });
}

function drawPlayer() {
  ctx.drawImage(robotImg, player.x, player.y, player.width, player.height);
}

function drawObstacles() {
  obstacles.forEach(ob => {
    ctx.fillStyle = ob.color;
    ctx.fillRect(ob.x - cameraX, ob.y, ob.width, ob.height);
  });
}

function drawUI() {
  ui.textContent = `Niveau: ${level} / ${maxLevel} - Vies: ${lives} - Temps: ${Math.ceil(timeRemaining)}s`;
}

function drawGameOver() {
  ctx.fillStyle = '#fff';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
  ctx.font = '24px sans-serif';
  ctx.fillText('Appuyez sur Entrer pour recommencer', canvas.width / 2, canvas.height / 2 + 40);
}

function drawVictory() {
  ctx.fillStyle = '#fff';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Victoire!', canvas.width / 2, canvas.height / 2);
  ctx.font = '24px sans-serif';
  ctx.fillText('Appuyez sur Entrer pour rejouer', canvas.width / 2, canvas.height / 2 + 40);
}

let last = 0;
function loop(timestamp) {
  const delta = (timestamp - last) / 1000;
  last = timestamp;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  update(delta);
  drawObstacles();
  drawPlayer();
  drawUI();

  if (gameState === 'gameover') {
    drawGameOver();
  } else if (gameState === 'victory') {
    drawVictory();
  }

  requestAnimationFrame(loop);
}

window.addEventListener('keydown', e => {
  const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
  if (isSpace && player.grounded && gameState === 'playing') {
    player.vy = JUMP_VELOCITY;
    player.grounded = false;
  } else if (gameState !== 'playing' && e.code === 'Enter') {
    // restart
    gameState = 'playing';
    level = 1;
    speed = 4;
    resetLevel(true);
  }
});

resetLevel(true);
requestAnimationFrame(loop);
</script>
</body>
</html>

